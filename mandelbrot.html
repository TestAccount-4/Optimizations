<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mandelbrot Explorer (GPU)</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: Arial, sans-serif; }
  #controls, #qualityControl {
    position: absolute; top: 10px;
    background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px;
  }
  #controls { left: 10px; }
  #qualityControl { right: 10px; }
  #controls label, #qualityControl label { display: block; margin-bottom: 8px; }
  #controls input[type="range"], #qualityControl input[type="range"] { width: 150px; }
  #controls select, #controls input, #qualityControl input { margin-left: 5px; }
  #info {
    position: absolute; bottom: 10px; left: 10px; color: #fff;
    background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 8px;
    font-size: 14px;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="controls">
  <!-- Your control elements go here -->
</div>
<div id="qualityControl">
  <!-- Quality controls here -->
</div>
<div id="info">
  <!-- Info elements here -->
</div>
<script type="x-shader/x-vertex" id="vertexShader">
attribute vec3 aVertexPosition;
void main(void) {
    gl_Position = vec4(aVertexPosition, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="fragmentShader">
precision highp float;
uniform vec2 uResolution;
uniform vec2 uCenter;
uniform float uZoom;
uniform int uMaxIter;
uniform vec3 uColors[4];
uniform float uColorSpeed;
uniform bool uSmoothColor;
uniform bool uColorCycle;

vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main(void) {
    vec2 z, c;
    c.x = (gl_FragCoord.x * 2.0 - uResolution.x) / uResolution.y / uZoom + uCenter.x;
    c.y = (gl_FragCoord.y * 2.0 - uResolution.y) / uResolution.y / uZoom + uCenter.y;
    z = c;
    float iter;
    for(iter = 0.0; iter < float(uMaxIter); iter++) {
        float x = (z.x * z.x - z.y * z.y) + c.x;
        float y = (z.y * z.x + z.x * z.y) + c.y;
        if((x * x + y * y) > 4.0) break;
        z.x = x;
        z.y = y;
    }
    
    float colorIndex = iter / float(uMaxIter);
    if (uSmoothColor) {
        colorIndex = colorIndex + 1.0 - log(log(length(z)) / log(2.0)) / log(2.0);
    }
    
    vec3 color;
    if (uColorCycle) {
        colorIndex = mod(colorIndex + uColorSpeed, 1.0);
    }
    color = hsv2rgb(vec3(colorIndex, 1.0 - colorIndex, 1.0));
    
    gl_FragColor = vec4(color, 1.0);
}
</script>
<script>
(function() {
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
        return;
    }

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    const shaderProgram = gl.createProgram();

    gl.shaderSource(vertexShader, document.getElementById('vertexShader').textContent);
    gl.shaderSource(fragmentShader, document.getElementById('fragmentShader').textContent);
    
    gl.compileShader(vertexShader);
    gl.compileShader(fragmentShader);

    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    gl.useProgram(shaderProgram);

    const vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(vertexPositionAttribute);

    const vertices = [
        -1.0, -1.0, 0.0,
         1.0, -1.0, 0.0,
        -1.0,  1.0, 0.0,
         1.0,  1.0, 0.0
    ];

    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    resizeCanvas();

    const uResolution = gl.getUniformLocation(shaderProgram, 'uResolution');
    gl.uniform2f(uResolution, canvas.width, canvas.height);

    const uCenter = gl.getUniformLocation(shaderProgram, 'uCenter');
    const uZoom = gl.getUniformLocation(shaderProgram, 'uZoom');
    const uMaxIter = gl.getUniformLocation(shaderProgram, 'uMaxIter');
    // Add more uniforms as needed for other controls

    function drawMandelbrot() {
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    // Add event listeners for controls, resize, etc., here
    window.addEventListener('resize', resizeCanvas);

    // Initial draw
    drawMandelbrot();

    // You need to handle controls change, zoom, pan, etc., by updating uniforms and calling drawMandelbrot()
})();
</script>
</body>
</html>

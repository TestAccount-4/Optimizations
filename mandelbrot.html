<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mandelbrot Explorer</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: Arial, sans-serif; }
  #controls, #qualityControl {
    position: absolute; top: 10px;
    background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px;
  }
  #controls {
    left: 10px;
  }
  #qualityControl {
    right: 10px;
  }
  #controls label, #qualityControl label { display: block; margin-bottom: 8px; }
  #controls input[type="range"], #qualityControl input[type="range"] { width: 150px; }
  #controls select, #controls input, #qualityControl input { margin-left: 5px; }
  #info {
    position: absolute; bottom: 10px; left: 10px; color: #fff;
    background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 8px;
    font-size: 14px;
  }
  #customPaletteInput {
    display: none;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="controls">
  <label>
    Color Palette:
    <select id="palette">
      <option value="rainbow">Rainbow</option>
      <option value="grayscale">Grayscale</option>
      <option value="fire">Fire</option>
      <option value="custom">Custom</option>
    </select>
  </label>
  <label id="customPaletteInput">
    Custom Colors (comma-separated hex values):
    <input type="text" id="customColors" placeholder="#ff0000,#00ff00,#0000ff">
  </label>
  <label>
    <input type="checkbox" id="smoothColor"> Smooth Coloring
  </label>
  <label>
    <input type="checkbox" id="colorCycle"> Color Cycling
  </label>
  <label>
    Max Iterations:
    <input type="range" id="maxIter" min="50" max="2000" value="500">
    <span id="maxIterValue">500</span>
  </label>
  <label>
    Color Speed:
    <input type="range" id="colorSpeed" min="1" max="20" value="5">
    <span id="colorSpeedValue">5</span>
  </label>
  <label>
    Mandelbrot Power:
    <input type="range" id="mandelbrotPower" min="2" max="10" value="2">
    <span id="mandelbrotPowerValue">2</span>
  </label>
</div>
<div id="qualityControl">
  <label>
    Render Quality:
    <input type="range" id="renderQuality" min="1" max="5" value="3">
    <span id="renderQualityValue">3</span>
  </label>
</div>
<div id="info">
  <div id="coords">Coords: (0, 0)</div>
  <div id="zoomLevel">Zoom Level: 1x</div>
</div>
<script>
(function() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let width, height;
  let minX = -2.5, maxX = 1, minY = -1.5, maxY = 1.5;
  let maxIter = parseInt(document.getElementById('maxIter').value);
  let palette = 'rainbow';
  let smoothColoring = false;
  let colorCycle = false;
  let cycleOffset = 0;
  let colorSpeed = parseInt(document.getElementById('colorSpeed').value);
  let renderQuality = parseInt(document.getElementById('renderQuality').value);
  let mandelbrotPower = parseFloat(document.getElementById('mandelbrotPower').value);
  let customColors = [];
  let dragging = false;
  let dragStartX, dragStartY;
  let zoomLevel = 1;
  let renderTimeout;

  const offscreenCanvas = document.createElement('canvas');
  const offscreenCtx = offscreenCanvas.getContext('2d');

  function resizeCanvas() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    offscreenCanvas.width = width;
    offscreenCanvas.height = height;

    const ratio = (maxX - minX) / (maxY - minY);
    const canvasRatio = width / height;
    if (canvasRatio > ratio) {
      const midX = (minX + maxX) / 2;
      const newWidth = (maxY - minY) * canvasRatio;
      minX = midX - newWidth / 2;
      maxX = midX + newWidth / 2;
    } else {
      const midY = (minY + maxY) / 2;
      const newHeight = (maxX - minX) / canvasRatio;
      minY = midY - newHeight / 2;
      maxY = midY + newHeight / 2;
    }

    drawMandelbrot();  // Full render after resizing
  }

  function parseCustomColors(input) {
    return input.split(',').map(color => {
      color = color.trim();
      if (color[0] !== '#') color = '#' + color;
      return color;
    });
  }

  function getColor(iter, z) {
    if (iter === maxIter) return [0, 0, 0];
    let mu = iter;
    if (smoothColoring) {
      mu = iter + 1 - Math.log(Math.log(z)) / Math.log(2);
    }
    mu = (mu + cycleOffset) % maxIter;
    const t = mu / maxIter;
    switch (palette) {
      case 'grayscale':
        const gray = t * 255;
        return [gray, gray, gray];
      case 'fire':
        return [Math.min(255, t * 512), Math.min(255, t * 128), 0];
      case 'custom':
        if (customColors.length === 0) return [0, 0, 0];
        const colorIndex = Math.floor(t * customColors.length);
        const color = customColors[colorIndex % customColors.length];
        const rgb = hexToRgb(color);
        return [rgb.r, rgb.g, rgb.b];
      default: // rainbow
        return [
          128 + 127 * Math.sin(2 * Math.PI * t),
          128 + 127 * Math.sin(2 * Math.PI * t + 2 * Math.PI / 3),
          128 + 127 * Math.sin(2 * Math.PI * t + 4 * Math.PI / 3)
        ];
    }
  }

  function hexToRgb(hex) {
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
      return r + r + g + g + b + b;
    });
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  function complexPow(re, im, power) {
    const modulus = Math.sqrt(re * re + im * im);
    const arg = Math.atan2(im, re);
    const modulusPower = Math.pow(modulus, power);
    const newRe = modulusPower * Math.cos(arg * power);
    const newIm = modulusPower * Math.sin(arg * power);
    return [newRe, newIm];
  }

  function drawMandelbrot(isLowRes = false) {
    const ctxToUse = isLowRes ? offscreenCtx : ctx;
    const imageData = ctxToUse.createImageData(width, height);
    const data = imageData.data;
    const dx = (maxX - minX) / width;
    const dy = (maxY - minY) / height;
    const step = isLowRes ? 10 : Math.ceil(6 - renderQuality);

    for (let py = 0; py < height; py += step) {
      const y0 = maxY - py * dy;
      for (let px = 0; px < width; px += step) {
        const x0 = minX + px * dx;
        let re = 0, im = 0, iter = 0;
        let reSq = 0, imSq = 0;

        while (reSq + imSq <= 4 && iter < maxIter) {
          const [newRe, newIm] = complexPow(re, im, mandelbrotPower);
          re = newRe + x0;
          im = newIm + y0;
          reSq = re * re;
          imSq = im * im;
          iter++;
        }

        const [r, g, b] = getColor(iter, reSq + imSq);
        for (let iy = 0; iy < step; iy++) {
          for (let ix = 0; ix < step; ix++) {
            const idx = 4 * ((py + iy) * width + (px + ix));
            if (idx < data.length) {
              data[idx] = r;
              data[idx + 1] = g;
              data[idx + 2] = b;
              data[idx + 3] = 255;
            }
          }
        }
      }
    }
    ctxToUse.putImageData(imageData, 0, 0);
    if (isLowRes) {
      ctx.drawImage(offscreenCanvas, 0, 0);  // Draw low-res buffer to screen
    }
    updateInfo();
  }

  function zoom(event) {
    event.preventDefault();
    const zoomFactor = event.deltaY < 0 ? 0.9 : 1.1;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const x0 = minX + (maxX - minX) * x / width;
    const y0 = maxY - (maxY - minY) * y / height;

    const newWidth = (maxX - minX) * zoomFactor;
    const newHeight = (maxY - minY) * zoomFactor;
    minX = x0 - newWidth * (x / width);
    maxX = x0 + newWidth * (1 - x / width);
    minY = y0 - newHeight * (1 - y / height);
    maxY = y0 + newHeight * (y / height);
    zoomLevel *= 1 / zoomFactor;

    drawMandelbrot(true);  // Low-res rendering during zoom
    clearTimeout(renderTimeout);
    renderTimeout = setTimeout(() => {
      drawMandelbrot();  // Full-res render after zoom ends
    }, 150);  // Adjust delay to control the frequency of full renders
  }

  function panStart(event) {
    dragging = true;
    dragStartX = event.clientX;
    dragStartY = event.clientY;
    event.preventDefault();
  }

  function panMove(event) {
    if (!dragging) return;
    const dx = (event.clientX - dragStartX) / width * (maxX - minX);
    const dy = (event.clientY - dragStartY) / height * (maxY - minY);
    minX -= dx;
    maxX -= dx;
    minY += dy;
    maxY += dy;
    dragStartX = event.clientX;
    dragStartY = event.clientY;

    drawMandelbrot(true);  // Low-res rendering during pan
    clearTimeout(renderTimeout);
    renderTimeout = setTimeout(() => {
      drawMandelbrot();  // Full-res render after pan ends
    }, 150);
  }

  function panEnd(event) {
    dragging = false;
    event.preventDefault();
  }

  function animate() {
    if (colorCycle) {
      cycleOffset = (cycleOffset + colorSpeed) % maxIter;
      drawMandelbrot();
    }
    requestAnimationFrame(animate);
  }

  function updateInfo() {
    document.getElementById('coords').textContent = `Center: (${((minX + maxX) / 2).toFixed(5)}, ${((minY + maxY) / 2).toFixed(5)})`;
    document.getElementById('zoomLevel').textContent = `Zoom Level: ${zoomLevel.toFixed(2)}x`;
  }

  // Event listeners
  document.getElementById('palette').addEventListener('change', (e) => {
    palette = e.target.value;
    if (palette === 'custom') {
      document.getElementById('customPaletteInput').style.display = 'block';
      const inputColors = document.getElementById('customColors').value.trim();
      if (inputColors) {
        customColors = parseCustomColors(inputColors);
      } else {
        customColors = [];
      }
    } else {
      document.getElementById('customPaletteInput').style.display = 'none';
    }
    drawMandelbrot();
  });

  document.getElementById('customColors').addEventListener('change', (e) => {
    const inputColors = e.target.value.trim();
    if (inputColors) {
      customColors = parseCustomColors(inputColors);
    } else {
      customColors = [];
    }
    drawMandelbrot();
  });

  document.getElementById('smoothColor').addEventListener('change', (e) => {
    smoothColoring = e.target.checked;
    drawMandelbrot();
  });

  document.getElementById('colorCycle').addEventListener('change', (e) => {
    colorCycle = e.target.checked;
    if (colorCycle) animate();
  });

  document.getElementById('maxIter').addEventListener('input', (e) => {
    maxIter = parseInt(e.target.value);
    document.getElementById('maxIterValue').textContent = maxIter;
    drawMandelbrot();
  });

  document.getElementById('colorSpeed').addEventListener('input', (e) => {
    colorSpeed = parseInt(e.target.value);
    document.getElementById('colorSpeedValue').textContent = colorSpeed;
  });

  document.getElementById('renderQuality').addEventListener('input', (e) => {
    renderQuality = parseInt(e.target.value);
    document.getElementById('renderQualityValue').textContent = renderQuality;
    drawMandelbrot();
  });

  document.getElementById('mandelbrotPower').addEventListener('input', (e) => {
    mandelbrotPower = parseFloat(e.target.value);
    document.getElementById('mandelbrotPowerValue').textContent = mandelbrotPower;
    drawMandelbrot();
  });

  window.addEventListener('resize', resizeCanvas);
  canvas.addEventListener('wheel', zoom);
  canvas.addEventListener('mousedown', panStart);
  canvas.addEventListener('mousemove', panMove);
  canvas.addEventListener('mouseup', panEnd);
  canvas.addEventListener('mouseleave', panEnd);

  // Initial setup
  resizeCanvas();
})();
</script>
</body>
</html>
